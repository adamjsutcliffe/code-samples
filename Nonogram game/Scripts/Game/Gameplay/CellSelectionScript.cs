using System;
using System.Collections;
using System.Collections.Generic;
using Peak.QuixelLogic.Scripts.Common;
using Peak.QuixelLogic.Scripts.ScenesLogic;
using Peak.QuixelLogic.Scripts.Settings.Autogenerated;
using UnityEngine;

namespace Peak.QuixelLogic.Scripts.Game.Gameplay
{
    public sealed class CellSelectionScript : MonoBehaviour
    {
        private bool selectionMode;
        public bool SelectionMode
        {
            get { return selectionMode; }
            set { selectionMode = value; }
        }

        private bool markMode;
        public bool MarkMode
        {
            get { return markMode; }
            set { markMode = value; }
        }

        private bool mouseDown;
        public bool MouseDown => mouseDown;

        private GameController gameController;

        private int selectionChainCount;
        private int markChainCount;

        public event Action<Vector2, Action> OnCellSelected;
        public event Action<Vector2, Action> OnCellDeselected;

        public event Action<Vector2, Action> OnCellMark;

        [SerializeField]
        private List<GridLabelScript> RowLabels = new List<GridLabelScript>();

        [SerializeField]
        private List<GridLabelScript> ColumnLabels = new List<GridLabelScript>();

        [SerializeField]
        private SoundSettingsKey cellSelectedSound;

        [SerializeField]
        private SoundSettingsKey cellDeselectedSound;

        [SerializeField]
        private SoundSettingsKey cellMarkSound;

        [SerializeField]
        private SoundSettingsKey cellUnmarkSound;

        private void Initialise()
        {
            gameController = SceneActivationBehaviour<GameLogicActivator>.Instance.GameController;
        }

        private void Awake()
        {
            Input.multiTouchEnabled = false;
        }

        public void IncrementSelectionChain(int number, bool increment = true)
        {
            if (number.Equals(0))
            {
                selectionChainCount = 0;
                return;
            }
            else
            {
                if (increment)
                {
                    selectionChainCount++;
                    SoundController.Instance.PlayAudioClip(cellSelectedSound, selectionChainCount);
                    return;
                }
                else
                {
                    selectionChainCount++;
                    SoundController.Instance.PlayAudioClip(cellDeselectedSound);
                    return;
                }
            }
        }

        public void IncrementMarkChain(int number, bool increment = true)
        {
            if (number.Equals(0))
            {
                markChainCount = 0;
                return;
            }
            else
            {
                if (increment)
                {
                    markChainCount++;
                    SoundController.Instance.PlayAudioClip(cellMarkSound, markChainCount);
                    return;
                }
                else
                {
                    markChainCount++;
                    SoundController.Instance.PlayAudioClip(cellUnmarkSound);
                    return;
                }
            }
        }

        public void SaveSelectedCellCoordinates(Vector2 SelectedCellCoordinates, Action isNotPaused = null)
        {
            OnCellSelected?.Invoke(SelectedCellCoordinates, () =>
            {
                RowLabels[(int)SelectedCellCoordinates.x - 1].CalculateCurrentSelectedCells((int)SelectedCellCoordinates.y, true);
                ColumnLabels[(int)SelectedCellCoordinates.y - 1].CalculateCurrentSelectedCells((int)SelectedCellCoordinates.x, true);

                isNotPaused?.Invoke();
            });
        }

        public void UnSaveSelectedCellCoordinates(Vector2 SelectedCellCoordinates, Action isNotPaused = null)
        {
            OnCellDeselected?.Invoke(SelectedCellCoordinates, () =>
            {
                RowLabels[(int)SelectedCellCoordinates.x - 1].CalculateCurrentSelectedCells((int)SelectedCellCoordinates.y, false);
                ColumnLabels[(int)SelectedCellCoordinates.y - 1].CalculateCurrentSelectedCells((int)SelectedCellCoordinates.x, false);

                isNotPaused?.Invoke();
            });
        }

        public void MarkCell(Vector2 MarkedCellCoordinates, Action isNotPaused = null)
        {
            OnCellMark?.Invoke(MarkedCellCoordinates, () =>
            {
                isNotPaused?.Invoke();
            });
        }

        private void OnMouseDown()
        {
            mouseDown = true;
        }

        private void OnMouseUp()
        {
            mouseDown = false;
        }
    }
}
