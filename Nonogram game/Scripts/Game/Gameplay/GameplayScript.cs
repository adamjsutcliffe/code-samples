using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Peak.QuixelLogic.Scripts.Autogenerated;
using Peak.QuixelLogic.Scripts.Common;
using Peak.QuixelLogic.Scripts.Common.AnalyticsScripts;
using Peak.QuixelLogic.Scripts.ScenesLogic;
using Peak.QuixelLogic.Scripts.Settings;
using Peak.QuixelLogic.Scripts.Settings.Autogenerated;
using UnityEngine;

namespace Peak.QuixelLogic.Scripts.Game.Gameplay
{
    /// <summary>
    /// To be attached to game play object i.e. a board or grid
    /// </summary>

    public sealed class GameplayScript : MonoBehaviour
    {
        //[SerializeField]
        //private SoundSettingsKey timerCountdownSound;

        #region Internal state

        /// <summary>
        /// The paused.
        /// </summary>
        private bool isPaused;

        /// <summary>
        /// Timer coroutine
        /// </summary>
        private Coroutine timerCoroutine;

        private MainGameData gameData;

        public RuleSettings CurrentGameSettings => gameData.Ruleset;
        public MainGameData GameData => gameData;
        public bool IsPaused => isPaused;

        #endregion

        #region Events

        public event GameStartedHandler OnGameStarted;
        public event GamePausedHandler OnPaused;
        public event GameResumedHandler OnResumed;
        public event GameRestartedHandler OnRestarted;
        public event PuzzleSolvedHandler OnPuzzleSolved;
        public event GameQuitHandler OnGameQuit;

        public event TimeChangedHandler OnGameTimeChanged;

        public event SelectFTUECells OnFtueCellSelection;

        public event MarkFTUECells OnFtueCellMark;

        #endregion

        [SerializeField]
        private CellSelectionScript cellSelectionScript;

        [SerializeField]
        private BoardCreationScript boardCreationScript;

        private List<Vector2> TargetCellsForCurrentPuzzle = new List<Vector2>(100);

        private List<Vector2> SelectedCellsForCurrentPuzzle = new List<Vector2>(100);

        private List<Vector2> possibleHintCells = new List<Vector2>(100);

        public bool IsFtue { get; private set; }

        private int inactiveSeconds;

        private void TryDeliverHint(Vector2? ForcedCellCoordinate = null)
        {
            SoundController.Instance.PlayAudioClip(SoundSettingsKey.Hintsound);

            if (!ForcedCellCoordinate.HasValue)
            {
                int possibleHintCount = (possibleHintCells.Count);
                int randomNumber = UnityEngine.Random.Range(0, possibleHintCount - 1);
                Vector2 chosenHintCell = possibleHintCells[randomNumber];
                boardCreationScript.DeliverHint(chosenHintCell);
                return;
            }
            else
            {
                Vector2 vector = new Vector2((int)ForcedCellCoordinate.Value.x, (int)ForcedCellCoordinate.Value.y);
                boardCreationScript.DeliverHint(vector);
            }
        }

        private void Awake()
        {
            boardCreationScript.ClearTargetCells += ClearTargetCells;
            boardCreationScript.SendTargetCell += AddTargetCellForCurrentPuzzle;

            cellSelectionScript.OnCellSelected += OnCellSelected;
            cellSelectionScript.OnCellDeselected += OnCellDeselected;

            cellSelectionScript.OnCellMark += OnCellMark;

            SceneActivationBehaviour<BoardUIActivator>.Instance.HintRequested += TryDeliverHint;
        }

        /// <summary>
        /// Initialize the gameplay
        /// </summary>
        public void Configure(RuleSettings rules, GameType gameType, int playerFilm, bool replay = false)
        {
            gameData = new MainGameData
            {
                Ruleset = rules,
                Replay = replay,
                GameType = gameType,
                PlayerFilmRemaining = playerFilm
            };

            isPaused = true;
        }

        private void OnCellMark(Vector2 CellCoordinate, Action isNotPaused)
        {
            if (!isPaused)
            {
                if (IsFtue)
                {
                    OnFtueCellMark?.Invoke(CellCoordinate, true);
                }

                isNotPaused?.Invoke();
                ResetInactiveSeconds();
            }
            else return;
        }

        private void OnCellSelected(Vector2 CellCoordinate, Action isNotPaused)
        {
            if (!isPaused)
            {
                isNotPaused?.Invoke();
                ResetInactiveSeconds();

                SelectedCellsForCurrentPuzzle.Add(CellCoordinate);

                if (IsFtue)
                {
                    OnFtueCellSelection?.Invoke(CellCoordinate, true);
                }

                // Remove selected cell as a possible hint cell
                for (int i = 0; i < possibleHintCells.Count; i++)
                {
                    if (possibleHintCells[i].Equals(CellCoordinate))
                    {
                        possibleHintCells.RemoveAt(i);
                    }
                }

                // check for remaining cells and disable hint
                if (SelectedCellsForCurrentPuzzle.Count.Equals(TargetCellsForCurrentPuzzle.Count - 1))
                {
                    SceneActivationBehaviour<ToolbarUIActivator>.Instance.HintButtonScript.DisableHint();
                }

                // check if selected amount = target amount
                if (SelectedCellsForCurrentPuzzle.Count.Equals(TargetCellsForCurrentPuzzle.Count))
                {
                    List<Vector2> TargetCellsToCheck = new List<Vector2>(TargetCellsForCurrentPuzzle);
                    CheckPuzzleSolution(TargetCellsToCheck);
                }
            }
            else return;
        }

        private void OnCellDeselected(Vector2 CellCoordinate, Action isNotPaused)
        {
            if (!isPaused && !IsFtue)
            {
                isNotPaused?.Invoke();
                ResetInactiveSeconds();

                //if (IsFtue)
                //{
                //    //OnFtueCellSelection?.Invoke(CellCoordinate, false);
                //}

                for (int i = 0; i < SelectedCellsForCurrentPuzzle.Count; i++)
                {
                    if (CellCoordinate.x.Equals(SelectedCellsForCurrentPuzzle[i].x) && CellCoordinate.y.Equals(SelectedCellsForCurrentPuzzle[i].y))
                    {
                        SelectedCellsForCurrentPuzzle.RemoveAt(i);
                    }
                }

                // Add only target cells to possible hint cells
                for (int i = 0; i < TargetCellsForCurrentPuzzle.Count; i++)
                {
                    if (TargetCellsForCurrentPuzzle[i].Equals(CellCoordinate))
                    {
                        possibleHintCells.Add(CellCoordinate);
                    }
                }

                // check for remaining cells and disable hint
                if (SelectedCellsForCurrentPuzzle.Count.Equals(TargetCellsForCurrentPuzzle.Count - 2) && SceneActivationBehaviour<GameLogicActivator>.Instance.GameController.Player.FtuePassed)
                {
                    SceneActivationBehaviour<ToolbarUIActivator>.Instance.HintButtonScript.EnableHint();
                }

                // ---
                if (SelectedCellsForCurrentPuzzle.Count.Equals(TargetCellsForCurrentPuzzle.Count))
                {
                    List<Vector2> TargetCellsToCheck = new List<Vector2>(TargetCellsForCurrentPuzzle);
                    CheckPuzzleSolution(TargetCellsToCheck);
                }
            }
            else return;
        }

        private void ClearTargetCells()
        {
            TargetCellsForCurrentPuzzle.Clear();
        }

        private void AddTargetCellForCurrentPuzzle(Vector2 CellCoordinates)
        {
            TargetCellsForCurrentPuzzle.Add(CellCoordinates);
            possibleHintCells.Add(CellCoordinates);
        }

        private void CheckPuzzleSolution(List<Vector2> TargetCellsToCheck)
        {
            int correctCells = 0;

            for (int i = 0; i < SelectedCellsForCurrentPuzzle.Count; i++)
            {
                for (int j = 0; j < TargetCellsToCheck.Count; j++)
                {
                    if (SelectedCellsForCurrentPuzzle[i].Equals(TargetCellsToCheck[j]))
                    {
                        correctCells += 1;
                    }
                    if (correctCells.Equals(TargetCellsForCurrentPuzzle.Count))
                    {
                        print("Correct puzzle!");

                        SceneActivationBehaviour<BoardUIActivator>.Instance.DisableTouchGrid();
                        Invoke(nameof(TriggerGameOver), 0.5f);
                        TargetCellsToCheck.Clear();
                    }
                }
            }
        }

        /// <summary>
        /// Triggers when the game is started.
        /// </summary>
        private void TriggerGameStarted()
        {
            print("[TEST] TriggerGameStarted     " + gameData.Replay);
            OnGameStarted?.Invoke(gameData);
        }

        /// <summary>
        /// Triggers when the game is paused.
        /// </summary>
        private void TriggerGamePaused()
        {
            print("[TEST] TriggerGamePaused");
            OnPaused?.Invoke(gameData);
            SceneActivationBehaviour<BoardUIActivator>.Instance.QuixelController.ShowHideCharacter(false);
        }

        /// <summary>
        /// Triggers when the game is resumed.
        /// </summary>
        private void TriggerGameResumed()
        {
            print("[TEST] TriggerGameResumed");
            OnResumed?.Invoke(gameData);
            SceneActivationBehaviour<BoardUIActivator>.Instance.QuixelController.ShowHideCharacter(true);
        }

        private void TriggerGameRestarted()
        {
            print("[TEST] TriggerGameRestarted");

            SceneActivationBehaviour<BoardUIActivator>.Instance.HintRequested -= TryDeliverHint;

            OnRestarted?.Invoke(gameData);

            // stops time
            SetTimer(false);
        }

        /// <summary>
        /// Triggers the game over.
        /// </summary>
        private void TriggerGameOver()
        {
            SoundController.Instance.PlayAudioClip(SoundSettingsKey.Postgamesoundsequence);
            iOSHapticFeedback.OnSelection();

            print("[TEST] TriggerGameOver");

            SceneActivationBehaviour<BoardUIActivator>.Instance.HintRequested -= TryDeliverHint;

            // disables input
            isPaused = true;

            // then fires
            OnPuzzleSolved?.Invoke(gameData);

            // stops time
            SetTimer(false);
        }

        /// <summary>
        /// Triggers when user leaves the game.
        /// </summary>
        private void TriggerGameQuit()
        {
            SceneActivationBehaviour<BoardUIActivator>.Instance.QuixelController?.ShowHideCharacter(false);

            boardCreationScript.QuitGame(() =>
            {
                SceneActivationBehaviour<BoardUIActivator>.Instance.HintRequested -= TryDeliverHint;

                print("[TEST] TriggerGameQuit");
                OnGameQuit?.Invoke(gameData);
            });

            //SceneActivationBehaviour<GameLogicActivator>.Instance.GameController.FilmGrantedHandler(1);
        }

        /// <summary>
        /// Triggers when the game time is changed.
        /// </summary>
        private void TriggerGameTimeChanged()
        {
            //print("[TEST] TriggerGameTimeChanged");
            OnGameTimeChanged?.Invoke(gameData);
        }

        /// <summary>
        /// Ticks the tock
        /// </summary>
        private IEnumerator TickTock()
        {
            if (gameData.TimeLimit == 0)
            {
                // no time limit

                timerCoroutine = null;
                yield break;
            }

            while (true)
            {
                yield return new WaitForSeconds(1);

                gameData.SecondsLeft--;

                inactiveSeconds++;

                TriggerGameTimeChanged();

                if (gameData.SecondsLeft <= 0)
                {
                    break;
                }

                if (inactiveSeconds.Equals(10))
                {
                    SceneActivationBehaviour<ToolbarUIActivator>.Instance.HintShakeEffect(true);
                }
            }

            // time runs out here
            timerCoroutine = null;
        }

        private void ResetInactiveSeconds()
        {
            inactiveSeconds = 0;
            SceneActivationBehaviour<ToolbarUIActivator>.Instance.HintShakeEffect(false);
        }

        /// <summary>
        /// Sets timer on or off
        /// </summary>
        public void SetTimer(bool isOn)
        {
            if (isOn)
            {
                gameData.SecondsLeft = gameData.TimeLimit;

                if (timerCoroutine == null)
                {
                    timerCoroutine = StartCoroutine(TickTock());
                }
                else
                {
                    Debug.LogWarning("Gameplay clock is already ticking. Resetting time.");
                }
            }
            else
            {
                if (timerCoroutine != null)
                {
                    StopCoroutine(timerCoroutine);
                    timerCoroutine = null;
                }
            }
        }

        /// <summary>
        /// Starts the session.
        /// </summary>
        public void StartSession(bool startTimer = true)
        {
            isPaused = false;

            SceneActivationBehaviour<ToolbarUIActivator>.Instance.SetPlayerHints();
            //SceneActivationBehaviour<ToolbarUIActivator>.Instance.ClickPencil();
            //SceneActivationBehaviour<ToolbarUIActivator>.Instance.SetModeToPencil();

            if (!startTimer)
            {
                // Hide top bars in case of ftue
                InterfaceController.Instance.Hide(GameWindow.BonusBarUI);

                SetTimer(false);
                IsFtue = true;
            }
            else
            {
                InterfaceController.Instance.Show(GameWindow.ToolbarUI);

                IsFtue = false;

                gameData.SecondsLeft = gameData.TimeLimit;
                TriggerGameTimeChanged();

                // triggers the game
                TriggerGameStarted();
            }
        }

        public void StartDelayedSession(bool playToContinue = false)
        {
            if (playToContinue)
            {
                InterfaceController.Instance.Show(GameWindow.BonusBarUI);
            }

            gameData.SecondsLeft = gameData.TimeLimit;
            SetTimer(true);

            IsFtue = false;

            // triggers default values
            TriggerGameTimeChanged();

            // triggers the game
            TriggerGameStarted();
        }

        public void PauseSession()
        {
            if (isPaused)
            {
                return;
            }
            if (timerCoroutine != null)
            {
                StopCoroutine(timerCoroutine);
            }

            isPaused = true;
            TriggerGamePaused();
        }

        public void ResumeSession()
        {
            if (!isPaused)
            {
                return;
            }
            isPaused = false;
            TriggerGameResumed();

            timerCoroutine = StartCoroutine(TickTock());
        }

        public void RestartSession()
        {
            TriggerGameRestarted();
        }

        public void QuitSession()
        {
            TriggerGameQuit();
        }

        private void OnDestroy()
        {
            SceneActivationBehaviour<BoardUIActivator>.Instance.HintRequested -= TryDeliverHint;
            boardCreationScript.ClearTargetCells -= ClearTargetCells;
            boardCreationScript.SendTargetCell -= AddTargetCellForCurrentPuzzle;
            cellSelectionScript.OnCellSelected -= OnCellSelected;
            cellSelectionScript.OnCellDeselected -= OnCellDeselected;
            cellSelectionScript.OnCellMark -= OnCellMark;
        }
    }
}