using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Peak.QuixelLogic.Scripts.Common;
using Peak.QuixelLogic.Scripts.Autogenerated;
using TMPro;
using Peak.QuixelLogic.Scripts.Settings;
using JetBrains.Annotations;
using Peak.QuixelLogic.Scripts.Common.AnalyticsScripts;
using System;
using UnityEngine.UI;

namespace Peak.QuixelLogic.Scripts.ScenesLogic
{
    public class PopupStoreMessageActivator : SceneActivationBehaviour<PopupStoreMessageActivator>
    {
        public enum StoreMessageType
        {
            Success = 0,
            Cancelled = 1,
            Connectivity = 2,
            Failed = 3
        }

        [SerializeField]
        private GameObject popupWindow;

        [SerializeField]
        private TextMeshProUGUI popupTitle;

        [SerializeField]
        private TextMeshProUGUI popupMessage;

        [SerializeField]
        private Image popupImage;

        [SerializeField]
        private TextMeshProUGUI buttonText;

        [SerializeField]
        private ParticleSystem coinFX;

        [SerializeField]
        private Sprite SuccessSprite;

        [SerializeField]
        private Sprite CancelledSprite;

        [SerializeField]
        private Sprite InternetSprite;

        private int coinRewardCount;

        private StoreMessageType type;

        private const float WaitTime = 2f;

        public override void Initialize()
        {
            base.Initialize();
        }

        public override void Show()
        {
            base.Show();
        }

        public override void Hide()
        {
            base.Hide();
        }

        public void ShowMessagePopup(StoreMessageType type, int rewardAmount = 0)
        {
            SoundController.Instance.PlayAudioClip(Settings.Autogenerated.SoundSettingsKey.Popupappear);

            this.type = type;
            popupTitle.text = TitleForType();
            popupMessage.text = MessageForType();
            popupImage.sprite = ImageForType();

            buttonText.text = ButtonTitleForType();

            popupWindow.SetActive(true);
            coinRewardCount = rewardAmount;
            if (coinRewardCount > 0)
            {
                SceneActivationBehaviour<GameLogicActivator>.Instance.GameController.CoinsGrantedHandler(coinRewardCount, CoinSourceType.Store);
            }
            Show();
        }

        [UsedImplicitly]
        public void ClaimRewardHandler()
        {
            if (type == StoreMessageType.Success)
            {
                SetCoinParticles();
                StartCoroutine(ClaimingRewardAnimation());
            }
            else
            {
                CleanUpAction();
            }
        }

        private IEnumerator ClaimingRewardAnimation()
        {
            int playerCoins = SceneActivationBehaviour<GameLogicActivator>.Instance.GameController.Player.Coins;
            SceneActivationBehaviour<UICoinCounterActivator>.Instance.CoinCounterClaim(playerCoins, coinRewardCount, 0.2f);

            GameObject coinTarget = SceneActivationBehaviour<UICoinCounterActivator>.Instance.CoinObject;
            Vector3 target = canvasCamera.WorldToScreenPoint(coinTarget.transform.position);
            Vector3 start = canvasCamera.WorldToScreenPoint(coinFX.transform.position);
            Vector3 diff = target - start;
            float particleAngle = 90.0f - (float)((180.0f / Math.PI) * Math.Atan(diff.y / diff.x));
            //print($"Coin target position: {coinTarget.transform.position} -> start: {start} target: {target} = {diff} angle: {particleAngle}");

            ParticleSystem.ShapeModule particleShape = coinFX.shape;
            particleShape.rotation = new Vector3(0, particleAngle, 0);

            coinFX.gameObject.SetActive(true);

            yield return new WaitForSeconds(WaitTime);

            coinFX.gameObject.SetActive(false);
            popupWindow.SetActive(false);

            CleanUpAction();
        }

        private void SetCoinParticles()
        {
            ParticleSystem.EmissionModule coinFxEmission = coinFX.emission;

            int cycles = (int)(coinRewardCount * 0.1f);
            float f = WaitTime / (float)cycles;
            //print($"PARTICLE CYCLES {cycles} frequency: {f}");
            coinFxEmission.SetBursts(new ParticleSystem.Burst[] {
                new ParticleSystem.Burst(0, 1, 1, cycles, f)
            });
        }

        private void CleanUpAction()
        {
            SceneActivationBehaviour<StoreUIActivator>.Instance.SetButtons(true);
            Hide();
        }

        private string TitleForType()
        {
            switch (type)
            {
                case StoreMessageType.Success:
                    return GameConstants.StoreMessages.TitleSuccess;
                case StoreMessageType.Cancelled:
                    return GameConstants.StoreMessages.TitleCancelled;
                case StoreMessageType.Connectivity:
                    return GameConstants.StoreMessages.TitleConnectivity;
                case StoreMessageType.Failed:
                    return GameConstants.StoreMessages.TitleFailed;
                default:
                    break;
            }
            return "ERROR";
        }

        private string MessageForType()
        {
            switch (type)
            {
                case StoreMessageType.Success:
                    return GameConstants.StoreMessages.MessageSuccess;
                case StoreMessageType.Cancelled:
                    return GameConstants.StoreMessages.MessageCancelled;
                case StoreMessageType.Connectivity:
                    return GameConstants.StoreMessages.MessageConnectivity;
                case StoreMessageType.Failed:
                    return GameConstants.StoreMessages.MessageFailed;
                default:
                    break;
            }
            return "ERROR";
        }

        private string ButtonTitleForType()
        {
            switch (type)
            {
                case StoreMessageType.Success:
                    return GameConstants.StoreMessages.ButtonClaim;
                case StoreMessageType.Cancelled:
                    return GameConstants.StoreMessages.ButtonContinue;
                case StoreMessageType.Connectivity:
                    return GameConstants.StoreMessages.ButtonContinue;
                case StoreMessageType.Failed:
                    return GameConstants.StoreMessages.ButtonContinue;
                default:
                    break;
            }
            return "ERROR";
        }

        private Sprite ImageForType()
        {
            switch (type)
            {
                case StoreMessageType.Success:
                    return SuccessSprite;
                case StoreMessageType.Cancelled:
                case StoreMessageType.Failed:
                    return CancelledSprite;
                case StoreMessageType.Connectivity:
                    return InternetSprite;
                default:
                    break;
            }
            return CancelledSprite;
        }
    }
}